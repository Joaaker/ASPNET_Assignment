// Dark Mode
// Generated by ChatGPT-03-high - Syncs both Dark mode toggles (Hamburger and Settings)
// Check if the user prefers dark mode based on system and adjust accordingly
// Saves Dark mode preference in local storage and prioritize locla storage
document.addEventListener('DOMContentLoaded', function () {
    const defaultToggle = document.getElementById('dark-mode');
    const hamburgerToggle = document.getElementById('hamburger-dark-mode');

    function updateDarkMode(isDark) {
        if (isDark) {
            document.body.classList.remove('light');
            document.body.classList.add('dark');
        } else {
            document.body.classList.remove('dark');
            document.body.classList.add('light');
        }
        if (defaultToggle) defaultToggle.checked = isDark;
        if (hamburgerToggle) hamburgerToggle.checked = isDark;

        localStorage.setItem('darkMode', isDark);
    }

    let storedDarkMode = localStorage.getItem('darkMode');
    if (storedDarkMode === null) {
        const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        updateDarkMode(prefersDark);
    } else {
        updateDarkMode(storedDarkMode === 'true');
    }

    if (defaultToggle) {
        defaultToggle.addEventListener('change', function () {
            updateDarkMode(this.checked);
        });
    }
    if (hamburgerToggle) {
        hamburgerToggle.addEventListener('change', function () {
            updateDarkMode(this.checked);
        });
    }
});


// Generated by ChatGPT-03-high - Makes the Dark Mode div clickable without closing the drop-down settings ul
document.querySelector('.dark-mode-container').addEventListener('click', function (e) { e.stopPropagation(); });




//Hamburger menu
const hamburgerBtn = document.getElementById('hamburgerBtn');
const menu = document.getElementById('menu');

hamburgerBtn.addEventListener('click', function() {
    menu.classList.toggle('active');
});

//Modal and Forms
document.addEventListener('DOMContentLoaded', () => {
    const previewSize = 150

    // Open Buttons
    const modalButtons = document.querySelectorAll('[data-modal="true"]')
    modalButtons.forEach(button => {
        button.addEventListener('click', () => {
            const modalTarget = button.getAttribute('data-target')
            const modal = document.querySelector(modalTarget)

            if (modal) {
                modal.style.display = 'flex';
                document.body.classList.add('modal-open');
            }

        })
    })


    // Close Buttons
    const closeButtons = document.querySelectorAll('[data-close="true"]')
    closeButtons.forEach(button => {
        button.addEventListener('click', () => {
            const modal = button.closest('._modal')
            if (modal) {
                modal.style.display = 'none'
                document.body.classList.remove('modal-open');

                //Clear Formdata
                modal.querySelectorAll('form').forEach(form => {
                    form.reset()

                    const imagePreview = form.querySelector('.image-preview')
                    if (imagePreview)
                        imagePreview.src = ''

                    const imagePreviewer = form.querySelector('.image-previewer')
                    if (imagePreviewer)
                        imagePreviewer.classList.remove('selected')
                })
            }
        })
    })

    //Handle Image previewer
    document.querySelectorAll('.image-previewer').forEach(previewer => {
        const fileInput = previewer.querySelector('input[type="file"]');
        const imagePreview = previewer.querySelector('.image-preview');

        previewer.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', ({ target: { files } }) => {
            const file = files[0];
            if (file) {
                processImage(file, imagePreview, previewer, previewSize);
            }
        })
    })

    // Handle submit forms
    const forms = document.querySelectorAll('form');
    forms.forEach(form => {
        form.addEventListener('submit', async (e) => {
            e.preventDefault();

            clearErrorMessages(form);

            const formData = new FormData(form);

            try {
                const res = await fetch(form.action, {
                    method: 'post',
                    body: formData
                });

                if (res.ok) {
                    const modal = form.closest('._modal')
                    if (modal)
                        modal.style.display = 'none';

                
                    window.location.reload()
                }
                else if (res.status === 400) {
                    const data = await res.json();

                    if (data.errors) {
                        Object.keys(data.errors).forEach(key => {
                            let input = form.querySelector(`[name="${key}"]`);
                            if (input) {
                                input.classList.add('input-validation-error');
                            }

                            let span = form.querySelector(`[data-valmsg-for="${key}"]`);
                            if (span) {
                                span.innerText = data.errors[key].join('\n');
                                span.classList.add('field-validation-error');
                            }
                        });
                    }
                }
            }
            catch {
                console.log('error submitting the form');
            }
        })
    })
})

// Clear error messages
function clearErrorMessages(form) {
    form.querySelectorAll('[data-val="true"]').forEach(input => {
        input.classList.remove('input-validation-error');
    });

    form.querySelectorAll('[data-valmsg-for]').forEach(span => {
        span.innerText = '';
        span.classList.remove('field-validation-error');
    });
}

// Image upload
async function loadImage(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader()

        reader.onerror = () => reject(new Error("Failed to upload file."))
        reader.onload = (e) => {
            const img = new Image()
            img.onerror = () => reject(new Error("Failed to load image."))
            img.onload = () => resolve(img)
            img.src = e.target.result
        }

        reader.readAsDataURL(file)
    })
}

// Process Image
async function processImage(file, imagePreview, previewer, previewSize = 150) {
    try {
        const img = await loadImage(file);
        const canvas = document.createElement('canvas');
        canvas.width = previewSize;
        canvas.height = previewSize;

        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, previewSize, previewSize);
        imagePreview.src = canvas.toDataURL('image/jpeg');
        previewer.classList.add('selected');
    }
    catch (error) {
        console.error('Failed on image-processing:', error);
    }
}

// Generated by ChatGPT-03-high - OnClick EditMember button => calls on [HttpGet]GetMember(string id) then populated _EditMember Modal with the information
document.addEventListener('DOMContentLoaded', function () {
    var editButtons = document.querySelectorAll('.edit-member-btn');

    editButtons.forEach(function (button) {
        button.addEventListener('click', function (e) {
            e.preventDefault();


            var memberId = button.getAttribute('data-member-id');

            fetch('/Members/GetMember?id=' + encodeURIComponent(memberId))
                .then(function (response) {
                    if (!response.ok) {
                        throw new Error('Error: ' + response.statusText);
                    }
                    return response.json();
                })
                .then(function (data) {
                    console.log(data)
                    document.querySelector('#edit-member-modal input[name="FirstName"]').value = data.firstName || '';
                    document.querySelector('#edit-member-modal input[name="LastName"]').value = data.lastName || '';
                    document.querySelector('#edit-member-modal input[name="Email"]').value = data.email || '';
                    document.querySelector('#edit-member-modal input[name="PhoneNumber"]').value = data.phoneNumber || '';
                    document.querySelector('#edit-member-modal input[name="JobTitle"]').value = data.jobTitle || '';
                    document.querySelector('#edit-member-modal input[name="StreetName"]').value = data.streetName || '';
                    document.querySelector('#edit-member-modal input[name="City"]').value = data.city || '';
                    document.querySelector('#edit-member-modal input[name="PostalCode"]').value = data.postalCode || '';
                    document.querySelector('#edit-member-modal input[name="DateOfBirth"]').value = data.dateOfBirth || '';

                    var idField = document.querySelector('#edit-member-modal input[name="Id"]');
                    if (idField) {
                        idField.value = data.id;
                    }


                })
                .catch(function (error) {
                    console.error('Error fetching member: ', error);
                });
        });
    });
});


//Notification dropdown
document.addEventListener('DOMContentLoaded', () => {
    initializeDropdowns();
    updateRelativeTimes();
    updateNotificationCount();
    updateDeadline();
    setInterval(updateTimes, 60 * 1000);
});

function closeAllDropdowns(exceptDropdown, dropdownElements) {
    dropdownElements.forEach(dropdown => {
        if (dropdown !== exceptDropdown) {
            dropdown.classList.remove('show')
        }
    })
}

function initializeDropdowns() {
    const dropdownTriggers = document.querySelectorAll('[data-type="dropdown-btn"]')

    const dropdownElements = new Set()
    dropdownTriggers.forEach(trigger => {
        const targetSelector = trigger.getAttribute('data-target')
        if (targetSelector) {
            const dropdown = document.querySelector(targetSelector)
            if (dropdown) {
                dropdownElements.add(dropdown)
            }
        }
    })

    dropdownTriggers.forEach(trigger => {
        trigger.addEventListener('click', (e) => {
            e.stopPropagation()
            const targetSelector = trigger.getAttribute('data-target')
            if (!targetSelector) return
            const dropdown = document.querySelector(targetSelector)
            if (!dropdown) return

            closeAllDropdowns(dropdown, dropdownElements)
            dropdown.classList.toggle('show')
        })
    })

    dropdownElements.forEach(dropdown => {
        dropdown.addEventListener('click', (e) => {
            e.stopPropagation()
        })
    })

    document.addEventListener('click', () => {
        closeAllDropdowns(null, dropdownElements)
    })
}


const connection = new signalR.HubConnectionBuilder()
    .withUrl("/notificationHub")
    .build()

connection.on("ReceiveNotification", function (notification) {
    const notifications = document.querySelector('.notifications')

    const item = document.createElement('div')
    item.className = 'notification-item'
    item.setAttribute('data-id', notification.id)
    item.innerHTML =
        `
    <div class="_img-container">
        <img class="image" src="${notification.icon}" />
    </div>
    <div class="_text-container">
        <div class="message">${notification.message}</div>
        <div class="_time" data-created="${new Date(notification.created).toISOString()}">${notification.created}</div>
    </div>
    <button class="_btn-close" onclick="dismissNotification('${notification.id}')"></button>
    `

    notifications.insertBefore(item, notifications.firstChild)

    updateRelativeTimes()
    updateNotificationCount()
})

connection.on("NotificationDismissed", function (notificationId) {
    removeNotification(notificationId)
})

connection.start().catch(error => console.error(error))

async function dismissNotification(notificationId) {
    try {
        const res = await fetch(`/api/notifications/dismiss/${notificationId}`, { method: 'POST' })
        if (res.ok) {
            removeNotification(notificationId)
        }
        else {
            console.error('Error removing notification')
        }
    }
    catch (error) {
        console.error('Error removing notification: ', error)
    }
}

function removeNotification(notificationId) {
    const element = document.querySelector(`.notification-item[data-id="${notificationId}"]`)
    if (element) {
        element.remove()
        updateNotificationCount()
    }
}

function updateNotificationCount() {
    const notifications = document.querySelector('.notifications')
    const notificationNumber = document.querySelector('.notification-number')
    const notificationNumberContainer = document.querySelector('._number-container')
    const notificationDropdownButton = document.querySelector('#notification-dropdown-button')
    const count = notifications.querySelectorAll('.notification-item').length

    if (notificationNumber) {
        notificationNumber.textContent = count
    }

    if (count > 0) {
        notificationDropdownButton.classList.add('notification-active')
        notificationNumberContainer.classList.add('notification-number-active')
    }

    if (count === 0) {
        notificationDropdownButton.classList.remove('notification-active')
        notificationNumberContainer.classList.remove('notification-number-active')
    }
}

function updateRelativeTimes() {
    const elements = document.querySelectorAll('._time');
    const now = new Date();

    elements.forEach(el => {
        const created = new Date(el.getAttribute('data-created'));
        const diff = now - created;
        const diffSeconds = Math.floor(diff / 1000);
        const diffMinutes = Math.floor(diffSeconds / 60);
        const diffHours = Math.floor(diffMinutes / 60);
        const diffDays = Math.floor(diffHours / 24);
        const diffWeeks = Math.floor(diffDays / 7);

        let relativeTime = '';

        if (diffMinutes < 1) {
            relativeTime = '0 min ago';
        } else if (diffMinutes < 60) {
            relativeTime = diffMinutes + ' min ago';
        } else if (diffHours < 2) {
            relativeTime = diffHours + ' hour ago';
        } else if (diffHours < 24) {
            relativeTime = diffHours + ' hours ago';
        } else if (diffDays < 2) {
            relativeTime = diffDays + ' day ago';
        } else if (diffDays < 7) {
            relativeTime = diffDays + ' days ago';
        } else {
            relativeTime = diffWeeks + ' weeks ago';
        }

        el.textContent = relativeTime;
    });
}

function updateDeadline() {
  const now = new Date();

  document.querySelectorAll('._time-left').forEach(el => {
    const end     = new Date(el.dataset.timeLeft);
    const diffMs  = end - now;
    const parent  = el.closest('.deadline');

    if (diffMs < 0) {
        el.textContent = 'Expired';
    parent?.classList.remove('near');
    return;
    }

    el.textContent = formatFuture(diffMs);

    if (diffMs < 7 * 24 * 60 * 60 * 1000) {
        parent?.classList.add('near');
    } else {
        parent?.classList.remove('near');
    }
  });
}

function formatFuture(diffMs) {
  const sec   = Math.floor(diffMs / 1000);
    const min   = Math.floor(sec / 60);
    const hrs   = Math.floor(min / 60);
    const days  = Math.floor(hrs / 24);
    const weeks = Math.floor(days / 7);

    if (days < 2)   return '1 day left';
    if (days < 7)   return days + ' days left';
    return weeks + ' weeks left';
};

//Project status buttons
document.addEventListener('DOMContentLoaded', () => {
    const buttons = document.querySelectorAll('.status-btn');
    const projectCards = document.querySelectorAll('.project-card');

    buttons.forEach(btn => {
        btn.addEventListener('click', () => {
            buttons.forEach(b => b.classList.remove('_selected'));
            btn.classList.add('_selected');

            const filter = btn.dataset.filter;

            projectCards.forEach(card => {
                const status = card.dataset.status;
                if (filter === 'all' || status === filter) {
                    card.style.display = 'grid';
                } else {
                    card.style.display = 'none';
                }
            });
        });
    });
});